# Домашняя работа по сравнению утилит pg_dump, pg_dumpall и pg_basebackup

## pg_dump
Утилита предназначена для создания логического бэкапа базы данных. Результатом её работы является набор команд для утилиты **psql**, который можно вывести в консоль или сохранить в файл.

Пример использования **pg_dump**:
```bash
sudo -u postgres pg_dump -d hcm -C -U postgres -p 5432 > main-hcm.sql
```

Восстановление из бэкапа производится с помощью утилиты **psql**, соответственно целевой кластер должен быть создан и настроен.

Пример восстановления из бэкапа:
```bash
sudo -u postgres psql -U postgres -p 5433 < main-hcm.sql
```

В данном примере не указана база данных, в которую происходит восстановление, так как при создании бэкапа был указан ключ **-C**. Этот ключ добавляет в список команд инструкцию для создания новой базы.

## pg_dump + pg_restore
С помощью утилиты **pg_dump** можно создать бэкап не только в виде набора команд для утилиты **psql**, но и в виде архива. В таком случае для восстановления необходимо использовать утилиту **pg_restore**.

Пример создания архива с помощью **pg_dump**:
```bash
sudo -u postgres pg_dump -d hcm -C -U postgres -Fc -p 5432 > main-hcm.gz
```

Восстановление из бэкапа производится с помощью утилиты **pg_restore**. Важной особенностью данного сценария является то, что база данных в целевом кластере должна быть создана заранее, несмотря на использование ключа **-C**.

Пример восстановления из бекапа:
```bash
sudo -u postgres pg_restore -d hcm -U postgres -p 5433 main-hcm.gz
```

Основной плюс использования архива в том, что мы сразу получаем файл с бэкапом меньшего размера.

## pg_dumpall
Утилита предназначена для создания логического бэкапа всего кластера, включая роли и табличные пространства. Результатом её работы тоже является набор команд для утилиты **psql**, который можно вывести в консоль или сохранить в файл.

Пример создания полного бэкапа с помощью **pg_dumpall**:
```bash
sudo -u postgres pg_dumpall > main-full.sql
```

Так же можно выгрузить в бэкап, например, только схему:
```bash
sudo -u postgres pg_dumpall --clean --schema-only > main-schema.sql
```

Результатом будет набор инструкций для утилиты **psql**. Пример восстановления из бекапа:
```bash
sudo -u postgres psql -U postgres -p 5433 < main-full.sql
```

Важной особенностью является то, что объекты, которые попали в бэкап, будут созданы заново. Но если целевой кластер содержит базы данных, которых нет в бэкапе, то эти базы данных останутся нетронуты.

## pg_basebackup
Утилита предназначена для создания физического бэкапа всего кластера.

Пример создания физического бэкапа:
```bash
sudo pg_createcluster -d /var/lib/postgresql/17/main3 17 main3
sudo rm -rf /var/lib/postgresql/17/main3
sudo -u postgres pg_basebackup -p 5432 -D /var/lib/postgresql/17/main3
```

В данном случае будет создана полная копия кластера, который доступен по порту 5432. Перед созданием физического бэкапа целевая директория должна быть пуста.

В отличие от логического, физический бэкап не является набором команд для утилиты **psql** и его можно восстановить только в той же версии и на той же архитектуре, что и источник.

## Сравнение скорости работы.

Для изучения скорости работы утилит по созданию бэкапов была использована средняя демонстрационная база postgrespro.  

### Выгрузка/восстановление одной БД.
Выгрузка в скрипт через **pg_dump** заняла 21 секунду. 
```bash
SECONDS=0; sudo -u postgres pg_dump -d demo -C -U postgres -p 5433 > main2-demo.sql; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

Восстановление из бэкапа с помощью **psql** заняло 38 секунд.
```bash
SECONDS=0; sudo -u postgres psql -U postgres -p 5434 < main2-demo.sql; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

Выгрузка в архив через **pg_dump** заняла 17 секунд.  
```bash
SECONDS=0; sudo -u postgres pg_dump -d demo -C -U postgres -Fc -p 5433 > main2-demo.gz; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

Восстановление из бэкапа с помощью **pg_restore** заняло 30 секунд.
```bash
SECONDS=0; sudo -u postgres pg_restore -d demo -U postgres -p 5434 main2-demo.gz; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

### Выгрузка/восстановление всего кластера.
Выгрузка логического бэкапа через **pg_dumpall** заняла 20 секунд.
```bash
SECONDS=0; sudo -u postgres pg_dumpall -U postgres -p 5433 > main2-full.sql; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

Восстановление из бэкапа с помощью **psql** заняло 37 секунд.
```bash
SECONDS=0; sudo -u postgres psql -U postgres -p 5434 < main2-full.sql; duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

Выгрузка физического бэкапа с помощью **pg_basebackup** заняла 5 секунд.
```bash
SECONDS=0; sudo -u postgres pg_basebackup -p 5433 -D /full-backup2;  duration=$SECONDS; echo "$((duration / 60)) minutes and $((duration % 60)) seconds elapsed."
```

### Выводы.
Быстрее всего создаётся физический бэкап, так как это, по сути, просто копия файлов кластера. Восстановление из физического бэкапа (если не рассматривать процедуру восстановления на определённую отметку времени) тоже требует лишь копирования файлов в каталог кластера и будет работать быстрее, чем восстановление из логического бэкапа.  
Среди инструментов для создания логического бэкапа быстрее работает выгрузка/восстановление с использованием архива.  
Различия в скорости при использовании **pg_dump** и **pg_dumpall**, при выгрузке в скрипт и восстановлении из него же, практически отсутствуют в тестовом примере. Возможно, что при наличии в кластере большого количества баз данных, ролей и других объектов, разница будет заметна.